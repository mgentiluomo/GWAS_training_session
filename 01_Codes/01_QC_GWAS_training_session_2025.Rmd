---
title: "GWAS training session"
output: html_notebook
authors:
  - name: "Dr. Manuel Gentiluomo"
    affiliation: "University of Pisa"
    url: "https://github.com/mgentiluomo"
    email: "manuel.gentiluomo@unipi.it"
  - name: "Riccardo Farinella"
    affiliation: "University of Pisa"
date: "`r format(Sys.Date(), '%B %d, %Y')`"
---

üß¨ Array Data Preparation: From Raw Genotypes to PLINK FormatBefore commencing any GWAS analysis, it's crucial to understand the origin and structure of the genetic data. This data is typically generated by Genotyping Array technologies (such as Illumina or Affymetrix) which detect genetic variants (the genotype) at thousands or millions of known genomic locations (SNPs).

1. üî† How Array Data (Raw Data) is Generated and Composed
A Genotyping Array is a chip that allows us to simultaneously test many Single Nucleotide Polymorphisms (SNPs).
Generation:
DNA from each individual is hybridised to the chip. The array software (e.g., Illumina's GenomeStudio) reads the signal intensity for the two possible alleles (genetic variants, e.g., A vs. G) at each SNP position.
Composition (Raw Genotype Data):
The result isn't immediately in a PLINK-readable format, but is usually a text file containing: 
- Sample Identifier (Sample ID): The individual being analysed.
- SNP Identifier (SNP ID): The tested genetic location.
- Raw Allelic Genotype: The raw genotype reading for that sample and SNP (e.g., AA, AG, GG, or sometimes in A/T, C/G format, etc.).

https://unipiit-my.sharepoint.com/:f:/g/personal/a035503_unipi_it/EvcItWiDOsRAn38jZlsxlZQBfta4Ifl0Y-W88ngGI7CZZQ?e=73j4pV

2. ‚û°Ô∏è Converting to PLINK FormatPLINK software is the de facto standard tool for GWAS analysis, but it requires data to be in a specific format to operate efficiently. This format is known as the PLINK Binary format (.bed, .bim, .fam). 
Extension | File | NameContent
.fam | Pedigree/Phenotype | Information about individuals (Family ID, Individual ID, Sex, Phenotype Status).
.bim | Genetic Map | Information about the SNPs (Chromosome, Physical Position, Alleles).
.bed | Genotype Data| The actual binary genotypes (AA, AG, GG, etc.) compressed into an efficient format for PLINK reading.

The Step from Array Matrix to PLINK:
1) Cleaning and Re-formatting: The raw output file must first be cleaned and converted into an intermediate text format (sometimes called PLINK Long Format or TPED/TFAM format).
2) PLINK Conversion: The command plink --make-bed is then used on the text format to generate the three essential binary files (.bed, .bim, and .fam).

Our entire training session will commence using files already in the PLINK Binary format.


############################################################ #############################
üõ†Ô∏è Environment Setup and Prerequisites
Before starting the analysis pipeline, please follow these steps to organize your files and ensure you have all the necessary software installed. This organization is critical for the reproducibility of the entire course.

1. Folder Setup
Create the Main Project Folder: On your Desktop, create a new folder named Class_folder.

Save the Notebook: Place this R Markdown Notebook (.Rmd file) directly inside the Class_folder/.

Data Placement: All subsequent data files (PLINK data, phenotype files, etc.) that you download will be placed inside the Class_folder/ as well, usually in the 01_Database/ directory, which will be created automatically.

Your final folder structure should look like this initially:

Desktop/
‚îî‚îÄ‚îÄ Class_folder/
    ‚îú‚îÄ‚îÄ Your_GWAS_Notebook.Rmd (This file)
    ‚îî‚îÄ‚îÄ (Other files will be created or placed here)

2. Required Software
You must have the following core software installed and accessible on your system:

R and RStudio: You should have the latest versions of R and the RStudio IDE installed. RStudio is required to run the R Markdown Notebook effectively.

PLINK: The entire Quality Control (QC) and Association Analysis pipeline relies heavily on the command-line genetic analysis tool, PLINK.

Action: You need to download the appropriate executable file for your operating system (Windows, macOS, or Linux) from the official PLINK website.

Accessibility: Ensure that the PLINK executable is either saved directly inside your Class_folder/ or, ideally, added to your system's PATH so that the system("plink ...") commands in this notebook can execute it from anywhere.

(PLINK installation and usage details will be covered in the next sections or in your accompanying slides.)

############################################################ #############################


üíª R Code Explanation: Package Installation and Setup
This specific code chunk is crucial for ensuring a smooth start to your GWAS training session. Its primary goal is to check, install, and load all the necessary R packages required for the downstream data analysis, manipulation, and visualisation.

```{r #1.a - Installation of needed packages}
# Installation of packages
packages <- c("base", "readxl", "readr", "dplyr", "ggplot2", "car", "utils", "qqman", "GGally", "ggfortify")
for (pkg in packages) {
  if (!require(pkg, character.only = TRUE)) {
    install.packages(pkg)
    library(pkg, character.only = TRUE)
  }
}
rm(packages,pkg)
```

A fundamental step in reproducible analysis is ensuring your script knows where to find the input data (data/ folder) and where to save the results (results/ folder).

When working with R Markdown, the working directory often defaults to the location of the .Rmd file itself. The following code automatically detects the path of the currently running notebook, regardless of whether you are executing it interactively in RStudio or rendering it to HTML/PDF.


Move this notebook inside the working folder
in our case is Class_folder/

```{r #1.b1 - Set of working directories}
#This chunk uses specialized functions to determine the exact folder where this notebook file resides.

# Check if the script is running interactively or being rendered
if (interactive()) {
  # Get the directory of the current R Markdown file in RStudio
  library(rstudioapi)
  notebook_dir <- dirname(rstudioapi::getActiveDocumentContext()$path)
} else {
  # Get the directory of the file during rendering
  notebook_dir <- dirname(normalizePath(knitr::current_input()))
}

# Print the directory for verification
print(notebook_dir)

```

This code chunk sets the local working directory and then defines a structured directory hierarchy to organise all intermediate files, data, and results generated throughout the multi-stage GWAS pipeline. This organisation is crucial for reproducibility and easy navigation.

Code Explanation: Defining Paths and Creating Folders
I. Establishing the Main Root
II. Defining the Pipeline Subdirectories
III. Creating the Folders

```{r #1.b2 - üõ†Ô∏è 1.b.2 - Setting up the GWAS Directory Structure}
# Creation of working directories
# Set the working directory to the notebook's directory
setwd(notebook_dir)

# Define the main directory as the current working directory
main <- paste0(getwd(), "/")

#The script first uses setwd(notebook_dir) to set the R working directory to the location detected in the previous chunk (1.b.1). 
#main is then defined as the absolute path to the notebook's directory. This serves as the root from which all subsequent folders will branch.

# Define subdirectory paths for various stages of the workflow
DB_dir <- paste0(main, "01_Database/")               # Directory for database files
QC_dir <- paste0(main, "02_QC/")                    # Directory for quality control files
PCA_dir <- paste0(main, "03_PCA/")                  # Directory for principal component analysis results
Imputation_dir <- paste0(main, "04_Imputation/")    # Directory for imputed data
PostImputation_dir <- paste0(main, "05_PostImputation/") # Directory for post-imputation quality control
Analysis_dir <- paste0(main, "06_Statistical_analysis/") # Directory for statistical analysis results
Other <- paste0(main, "Other/")                    # Directory for miscellaneous files

# Combine all directory paths into a list for easier handling
dirs <- c(DB_dir, QC_dir, PCA_dir, Imputation_dir, PostImputation_dir, Analysis_dir, Other)

# Create the directories if they don't exist
for (dir in dirs) {
  if (!dir.exists(dir)) {                          # Check if the directory already exists
    dir.create(dir, recursive = TRUE)             # Create the directory (and parent directories, if needed)
  }
}

# Print a confirmation message
text <- paste("End of chunk #1.b - Creation of working directories", "Your MAIN working directory is:", main, "PLEASE verify!",sep = "\n") 
cat(text)        
# End of chunk 1

```

```{r 1.b3 - üß© Download required database files}
# Step 1.b.3 ‚Äî Download input files into 01_Database

# Define the target directory
DB_dir <- file.path(main, "01_Database")

# Define URLs (raw GitHub links)
files_to_download <- list(
  sex   = "https://raw.githubusercontent.com/mgentiluomo/GWAS_training_session/main/02_Database/Sex.txt",
  covar = "https://raw.githubusercontent.com/mgentiluomo/GWAS_training_session/main/02_Database/general_covar.txt",
  pheno = "https://raw.githubusercontent.com/mgentiluomo/GWAS_training_session/main/02_Database/pheno.txt",
  bim   = "https://raw.githubusercontent.com/mgentiluomo/GWAS_training_session/main/02_Database/Databases/DB_A.bim",
  fam   = "https://raw.githubusercontent.com/mgentiluomo/GWAS_training_session/main/02_Database/Databases/DB_A.fam",
  linktobed ="https://github.com/mgentiluomo/GWAS_training_session/blob/main/02_Database/Databases/linktoBEDfile.txt"
)

# Loop to download each file
for (name in names(files_to_download)) {
  dest_file <- file.path(DB_dir, basename(files_to_download[[name]]))
  
  # Download file if it doesn't already exist
  if (!file.exists(dest_file)) {
    message("‚¨áÔ∏è Downloading ", name, " file...")
    download.file(files_to_download[[name]], destfile = dest_file, mode = "wb")
  } else {
    message("‚úÖ File already exists: ", basename(dest_file))
  }
}

# Confirm that files are present
cat("üìÇ Files now available in:", DB_dir, "\n")
print(list.files(DB_dir, pattern = "txt$|bim$|fam$", full.names = TRUE))

```


 #2 Plink
Download Links for PLINK 2.0

Link to PLINK2 website https://www.cog-genomics.org/plink/2.0/

You can download PLINK 2.0 for various operating systems using the links below:

Build Alpha 6.1 (14 Nov 2024)
#### Linux
# - [PLINK 2.0 for Linux (AVX2 Intel)](https://s3.amazonaws.com/plink2-assets/alpha6/plink2_linux_avx2_20241114.zip)
# - [PLINK 2.0 for Linux (AVX2 AMD)](https://s3.amazonaws.com/plink2-assets/alpha6/plink2_linux_amd_avx2_20241114.zip)
# - [PLINK 2.0 for Linux (64-bit Intel)](https://s3.amazonaws.com/plink2-assets/alpha6/plink2_linux_x86_64_20241114.zip)
# - [PLINK 2.0 for Linux (32-bit)](https://s3.amazonaws.com/plink2-assets/alpha6/plink2_linux_i686_20241114.zip)

#### macOS
# - [PLINK 2.0 for macOS (M1)](https://s3.amazonaws.com/plink2-assets/alpha6/plink2_mac_arm64_20241114.zip)
# - [PLINK 2.0 for macOS (AVX2)](https://s3.amazonaws.com/plink2-assets/alpha6/plink2_mac_avx2_20241114.zip)
# - [PLINK 2.0 for macOS (64-bit)](https://s3.amazonaws.com/plink2-assets/alpha6/plink2_mac_20241114.zip)

#### Windows
# - [PLINK 2.0 for Windows (AVX2)](https://s3.amazonaws.com/plink2-assets/alpha6/plink2_win_avx2_20241114.zip)
# - [PLINK 2.0 for Windows (64-bit)](https://s3.amazonaws.com/plink2-assets/alpha6/plink2_win64_20241114.zip)
# - [PLINK 2.0 for Windows (32-bit)](https://s3.amazonaws.com/plink2-assets/alpha6/plink2_win32_20241114.zip)

# For more details and additional versions, visit the [PLINK 2.0 Homepage](https://www.cog-genomics.org/plink/2.0/).

---

### Instructions
1. Click on the appropriate link for your operating system.
2. The download will start immediately.
3. Extract the downloaded ZIP file and follow the instructions in the [PLINK 2.0 Documentation](https://www.cog-genomics.org/plink/2.0/).

```{r download_and_prepare_plink2}
# Define the URL of the file to download #copy and paste the correct PLINK2 URL
plink_url <- "https://s3.amazonaws.com/plink2-assets/alpha6/plink2_win64_20251123.zip" # <-PASTE Here the link to Plink2 software

# Estrai automaticamente il nome del file dall'URL
file_name <- basename(plink_url)

# Definisci il percorso di destinazione
dest_file <- file.path(notebook_dir, file_name)

# Download the file using HTTPS
download.file(url = plink_url, destfile = dest_file, mode = "wb")

# Optional: confirm the file exists
file.exists(dest_file)

# Find all ZIP files in the directory whose names contain "plink2"
zip_files <- list.files(
  path = notebook_dir,
  pattern = "plink2.*\\.zip$",   # regex: contains "plink2" and ends with ".zip"
  full.names = TRUE
)

# Loop through each matching ZIP file and unzip it
for (zf in zip_files) {
  # Create an extraction folder with the same name as the ZIP file (without .zip)
  extract_dir <- file.path(notebook_dir, tools::file_path_sans_ext(basename(zf)))
  
  # Create the directory if it doesn‚Äôt exist
  if (!dir.exists(extract_dir)) dir.create(extract_dir)
  
  # Unzip the contents
  unzip(zipfile = zf, exdir = extract_dir)
  
  # Print a confirmation message
  message("Extracted: ", basename(zf), " ‚Üí ", extract_dir)
}

# Find any file inside the extracted folder that contains "plink" in its name
  plink_files <- list.files(
    path = extract_dir,
    pattern = "plink",
    full.names = TRUE,
    recursive = TRUE
  )
  
  # Copy each found file back into the main notebook directory
  for (pf in plink_files) {
    file.copy(from = pf, to = notebook_dir, overwrite = TRUE)
    message("Copied: ", basename(pf), " ‚Üí ", notebook_dir)
  }


# Optional: check that the plink files are now in the main directory
list.files(notebook_dir, pattern = "plink", full.names = TRUE)
```


```{r #2 Plink}
# Plink testing

# Ensure the PLINK executable is in the main directory
# Before running the following commands, copy and paste the PLINK executable (e.g., plink2) 
# into the main directory. This ensures the system can locate and execute PLINK commands.

# 1. Retrieve system information
os_name <- Sys.info()["sysname"]

# 2. Define the base PLINK command based on the operating system
if (os_name == "Windows") {
    # On Windows, the executable can usually be called directly (e.g., plink2.exe)
    plink_command <- "plink2"
    
} else if (os_name == "Darwin" || os_name == "Linux") {
    # 'Darwin' is the macOS kernel.
    # On Mac/Linux, we use "./" to indicate the current directory
    plink_command <- "./plink2"
    
} else {
    # Fallback case for other operating systems
    stop("Unsupported or unidentified operating system.")
}

# 3. Print the result for verification
cat("Detected Operating System:", os_name, "\n")
cat("PLINK command to be used:", plink_command, "\n")

# --- PLINK COMMAND DECLARATION ---

# üíª For Mac (macOS) and Linux users:
# We must use "./" to specify the executable in the current directory.
# plink_command <- "./plink2"

# üñ•Ô∏è For Windows users:
# The executable can typically be called directly by name.
# plink_command <- "plink2"

# ‚ö†Ô∏è ACTION REQUIRED: Uncomment ONE of the two lines above based on your system.

# --- End of Declaration ---


# --- Example Usage ---

# Execute the PLINK version check command
# This will automatically adapt to the operating system
system(paste(plink_command, "--version"))

# Verify the functionality of Plink
# This command checks the installed version of Plink
system(paste(plink_command, "--version"))

# This command displays the list of available functions in Plink
system(paste(plink_command, "--help"))

# Print a confirmation message for the end of this code chunk
print(system(paste(plink_command, "--version")))
print("End of chunk 2")
# End of chunk 2

```

‚ö†Ô∏è Important Note for Mac Users (Gatekeeper)
The PLINK executable (plink2) is often downloaded outside of the official Apple App Store and may not be signed by an identified developer. Consequently, the macOS operating system (via its security feature, Gatekeeper) will likely block the file from running the first time you try to execute it, displaying a warning message such as: "The software cannot be opened because the developer cannot be verified."

‚úÖ How to Allow PLINK to Run
To override this security block and grant permission for the executable:

Attempt to Run the Command: Try to run the PLINK command (./plink2 --version) once in your R script or in the Terminal. The system will display the block warning.

Open System Settings: Go to Apple Menu (Ô£ø) > System Settings (or System Preferences on older macOS versions).

Navigate to Security: Click on Privacy & Security in the sidebar.

Find the Blocked App: Scroll down to the Security section. You should see a message mentioning the blocked PLINK software and an "Open Anyway" button next to it.

Confirm and Open: Click the "Open Anyway" button. You may be prompted to enter your administrator password. A final confirmation dialogue will appear; click "Open".

Once this exception is made, you will be able to run plink2 from the command line or within your R script without further warnings.
############################################


The first essential step in Sample QC is checking for inconsistencies between the reported sex (as listed in the .fam file or provided as an external phenotype) and the genetically inferred sex (derived from X chromosome heterozygosity). Discrepancies can bias subsequent calculations like HWE checks.
Code Explanation: The 7-Step Sex Check Protocol
This block automates a rigorous process using both PLINK (for genetic calculations and filtering) and R (for viewing and selecting problematic samples).

Step	
R/PLINK Action	
Purpose

1: Update Sex Data	
system("plink --bfile ... --update-sex ...")
Synchronises the sex information in the current .fam file (DB_A_updated) with an external file (Sex.txt). This ensures we start with the most current reported data. A new binary file (QC1_sex) is created.
---------
2: Verify Consistency
system("plink ... --check-sex ...")
PLINK calculates the genetically inferred sex based on X chromosome data. It generates a report (results_checksex.sexcheck) listing the expected sex, the inferred sex, and a STATUS field (OK or PROBLEM).
--------
3-4: Identify Problems
read_table(...), filter(...), write.table(...)
R takes over: The .sexcheck file is loaded. We use dplyr::filter to isolate only individuals where the STATUS is "PROBLEM" (i.e., male reported but genetically female, or vice-versa). The IDs of these individuals are saved to a clean file (sex-discrepancy.txt).
--------
5: Remove Problematic Samples
system("plink ... --remove ...")
PLINK removes the identified samples listed in sex-discrepancy.txt. This creates the next clean dataset (QC2_sex)
--------
6: Investigate Discrepancies (Optional)
read.delim(...), merge(...)
This step is for diagnostic purposes. It loads the .hh (homozygosity haploid) output from PLINK and merges it with the .bim file to analyze the genomic location of the variants that caused the sex discrepancy flag. This helps ensure the issue is biological and not a systematic array problem.
--------
7: Clean up Sex Discrepancies
system("plink ... --set-hh-missing ...")
This is a final cleaning step: it sets the genotypes of the variants that were inconsistent with the inferred sex to missing (NA). This prevents these specific variants from causing further issues in downstream analysis, resulting in the final file for this step (QC2_sex_cleaned).

```{r #3.a - Quality Control (QC) Check for sex discrepancies --update-sex}
# SECTION 1: Check for sex discrepancies

# Step 1: Update sex data
# This updates the sex information based on the file "Sex.txt" 
# and creates a new binary file with the updated data.
system(paste(plink_command, "--bfile 01_Database/DB_A --update-sex 01_Database/Sex.txt --make-bed --out 02_QC/QC1_sex"))
```


```{r #3.a - Quality Control (QC) Check for sex discrepancies --check-sex}
# Step 2: Verify consistency between reported and genetic sex
# This generates a report on discrepancies between reported and genetic sex.
system(paste(plink_command, " --bfile 02_QC/QC1_sex --check-sex min-male-xf=0.8  --out 02_QC/results_checksex"))

# --check-sex compares sex assignments in the input dataset with those imputed from chrX inbreeding coefficients and/or chrY valid genotype call count/rate (heterozygous genotype calls are invalid on chrY), and writes a report to plink2.sexcheck.
# estimates smaller than 0.2 yield female calls, and values larger than 0.8 yield male calls.

```

If 'max-female-xf=' and/or 'min-male-xf=' are specified, chrX is used if present.
If 'max-female-ycount=', 'min-male-ycount=', 'max-female-yrate=', or 'min-male-yrate=' are specified, chrY is used if present.
If both chrX and chrY are usable, sex is only called if both conditions are satisfied. Similarly, if both count and rate are specified for chrY, the strictest condition must be satisfied.
If no thresholds are specified at all, a warning is printed, and then the run proceeds as if the parameters were "min-male-xf=1 max-female-yrate=0". In this case, unless you're just sanity-checking pre-cleaned data, you should look at the distributions of xf and yrate in the .sexcheck output file, and then rerun --check-sex with data-derived thresholds.
On chrX, male F-statistics should be in a big clump near 1, while female F-statistics should be centered near zero but can be widely dispersed.
On chrY, female valid-genotype rates should be in a big clump near 0, while male valid-genotype rates should be consistently higher but can be dispersed.

```{r #3.a - Quality Control (QC) Check for sex discrepancies - view checksex}
# Step 3: Review the results
# Load and visualise the results from the sex check.
results_checksex <- read_table(paste(QC_dir, "results_checksex.sexcheck", sep = ""))
results_checksex <- results_checksex %>%
  rename(FID = `#FID`)
View(results_checksex)
```


```{r #3.a - Quality Control (QC) Check for sex discrepancies - remove sex-discrepancy}
# Step 4: Identify individuals with sex inconsistencies
# Filter out individuals marked as "PROBLEM" in the results.
results_checksex <- filter(results_checksex, STATUS == "PROBLEM") %>%
  select(FID, IID)

# Save the list of problematic individuals to a file.
write.table(as.data.frame(results_checksex), paste(QC_dir, "sex-discrepancy.txt", sep = ""), sep = "\t", quote = FALSE, row.names = FALSE, col.names = FALSE)

# Step 5: Remove individuals with sex inconsistencies
# Exclude the individuals identified in the previous step.
system(paste(plink_command, " --bfile 02_QC/QC1_sex --remove 02_QC/sex-discrepancy.txt --make-bed --out 02_QC/QC2_sex"))
```


```{r #3.a - Quality Control (QC) Check for sex discrepancies}
# Step 6: Quality Control (QC) - Check for sex discrepancies
# Run this section only if the .hh file exists

hh_file <- file.path(main, "02_QC/QC2_sex.hh")

if (file.exists(hh_file)) {
  message("‚úÖ File found: running sex discrepancy QC steps...")

  # Load the variant data related to sex discrepancies for detailed analysis.
  QC2_sex_variants <- read.delim(hh_file, header = FALSE)
  BIM <- read.delim(file.path(main, "02_QC/QC2_sex.bim"), header = FALSE)

  # Assign column names for better understanding.
  names(BIM) <- c("Chr", "SNP", "cM", "Pos", "A1", "A2")
  names(QC2_sex_variants) <- c("FID", "IID", "SNP")

  # Merge variant data with BIM file for additional information.
  QC2_sex_variants <- merge(QC2_sex_variants, BIM, by = "SNP")

  # Summary of chromosome distribution for problematic variants.
  summary(as.factor(QC2_sex_variants$Chr))

  # Step 7: Clean up sex discrepancies
  # Set problematic variants to missing.
  system(paste(plink_command,
               "--bfile 02_QC/QC2_sex --set-hh-missing --make-bed --out 02_QC/QC2_sex"))
  
  message("‚úÖ QC2 sex discrepancy cleaning completed.")

} else {
  message("‚ö†Ô∏è File 'QC2_sex.hh' not found ‚Äî skipping sex discrepancy QC steps.")
}
```

This completed the sex check and resulted in a clean PLINK dataset (QC2_sex_cleaned). What is the next QC step in your pipeline?
Raw array data sometimes includes markers that are not located on the main human chromosomes, such as mitochondrial DNA (MT), pseudo-autosomal regions (PARs) that need special handling, or unmapped markers (coded as 0 in the .bim file). These non-standard markers can interfere with downstream analyses, particularly PCA and imputation.

This step ensures we retain only the genetic data relevant for standard association testing by filtering to chromosomes 1 through 23 (where 23 typically represents the X chromosome, depending on the PLINK version and input data conventions).

The following command uses a simple PLINK flag to keep only markers assigned to chromosomes 1 through 23.
#Command
PLINK Action
@Purpose
--
# plink --bfile ...
Loads the cleaned data from the sex check (QC2_sex_cleaned).
@Sets the input dataset.
--------
# --chr 1-23
Filters the data to retain only markers (SNPs) whose chromosome column in the .bim file is between 1 and 23, inclusive.
@Excludes mitochondrial and unplaced markers.
--------
# --make-bed --out ...
Creates the new binary files: QC3_chr_selection.bed, .bim, and .fam.
@Saves the filtered dataset for the next QC step.

```{r #3.b - Quality Control (QC) Chromosome selection}
# SECTION 2: Chromosome selection

# Retain only autosomal and sex chromosomes (1-23).
system(paste(plink_command, " --bfile 02_QC/QC2_sex --chr 1-23 --make-bed --out 02_QC/QC3_chr_selection"))
```


3.c - Quality Control (QC): Minor Allele Frequency (MAF) Filtering üìâ
The Minor Allele Frequency (MAF) is the frequency of the least common allele at a specific SNP position within your study population.
Variants with a very low MAF (e.g., less than 1%) are generally excluded from standard GWAS because:
- Low Statistical Power: It is extremely difficult to achieve statistical significance for associations involving very rare variants, especially with smaller sample sizes.
- Genotyping Errors: Low MAF variants are more susceptible to being confused with random genotyping errors.

This step sets a standard threshold of $1\%$ ($0.01$).

```{r #3.c - Quality Control (QC) Minor Allele Frequency (MAF) filtering}
# SECTION 3: Minor Allele Frequency (MAF) filtering

# Exclude SNPs with a minor allele frequency (MAF) below 1%.
system(paste(plink_command, " --bfile 02_QC/QC3_chr_selection --maf 0.01 --write-snplist --make-bed --out 02_QC/QC4_maf"))
```


3.d - Quality Control (QC): Missing Data and Call Rate Filtering üìä
The Call Rate refers to the percentage of non-missing genotype calls available for a given SNP or sample. High missingness rates indicate unreliable data and must be filtered out. We apply two distinct filters: one for SNPs (--geno) and one for samples (--mind).

I. SNP Missingness (--geno)
The --geno filter removes markers (SNPs) where a high proportion of individuals have missing genotype data.

Rationale: A SNP with a high missing rate is often associated with a failed probe on the array or a complex genomic region that is difficult to genotype accurately. Retaining such SNPs introduces noise into the analysis.

II. Sample Missingness (--mind)
The --mind filter removes individuals (samples) that have missing genotype data across a high proportion of all the tested markers.

Rationale: An individual with a high missing rate usually indicates poor quality or low quantity of the starting DNA material. Retaining such individuals can disproportionately affect the accuracy of allele frequency and association estimates.

```{r #3.d - Quality Control (QC) Call rate filtering --geno}
# SECTION 4: Call rate filtering

# Exclude SNPs with missing genotype data above 5%.
system(paste(plink_command, " --bfile 02_QC/QC4_maf --geno 0.05 --write-snplist --make-bed --out 02_QC/QC5_geno"))
```


```{r #3.d - Quality Control (QC) Call rate filtering --mind}
# Exclude individuals with missing genotype data above 10%.
system(paste(plink_command, " --bfile 02_QC/QC5_geno --mind 0.10 --make-bed --out 02_QC/QC6_mind"))
```


3.e - Quality Control (QC): Heterozygosity Check üß¨
The Heterozygosity Rate measures the proportion of genetic markers at which an individual possesses two different alleles (i.e., is heterozygous). An individual's observed heterozygosity should fall within a normal range relative to the study population.
Rationale for Filtering
Samples showing extreme heterozygosity rates are usually indicative of problems:
- Excessive Heterozygosity (Outlier High): Often suggests sample contamination (DNA from two individuals mixed) or, less commonly, unknown cryptic relatedness.
- Low Heterozygosity (Outlier Low): Can indicate inbreeding or a hidden technical issue, such as contamination with non-human DNA.

We use a standard threshold to identify these outliers: 3 Standard Deviations (SD) away from the population mean.

```{r #3.e - Quality Control (QC) Heterozygosity check --het}
# SECTION 5: Heterozygosity check

# Calculate heterozygosity rates for each individual.
system(paste(plink_command, " --bfile 02_QC/QC6_mind --het --out 02_QC/heterozygosity"))
```


```{r #3.e - Quality Control (QC) Heterozygosity check}
# Load heterozygosity data and identify outliers (¬±3 SD from the mean).
dat <- read.delim(paste(QC_dir, "heterozygosity.het", sep = ""), header = TRUE, quote="")
dat <- dat %>%
  rename(FID = `X.FID`)
m <- mean(dat$F)
s <- sd(dat$F)
valid <- subset(dat, F <= m + 3 * s & F >= m - 3 * s)

# Save the list of valid individuals.
write.table(valid[, c("FID", "IID")], paste(QC_dir, "DB_valid_sample.txt", sep = ""), quote = FALSE, row.names = FALSE)

# Retain only individuals with acceptable heterozygosity.
system(paste(plink_command, " --bfile 02_QC/QC6_mind --keep 02_QC/DB_valid_sample.txt --make-bed --out 02_QC/QC7_het"))
```


3.f - Quality Control (QC): Cryptic Relatedness Check üîó
Cryptic Relatedness refers to family ties (e.g., first or second-degree relatives) within a study cohort that were not known or reported initially. GWAS association testing assumes independence among samples. To prevent inflated results, related individuals must be identified and removed, or accounted for in the statistical model.

We use a two-part process: first, creating a set of independent markers, and second, calculating the genetic relationship between all pairs of individuals.

```{r #3.f - Quality Control (QC) Cryptic relatedness check --indep-pairwise}
# SECTION 6: Cryptic relatedness check

# Step 1: Prune SNPs for relatedness analysis.
system(paste(plink_command, " --bfile 02_QC/QC7_het --indep-pairwise 200 50 0.25 --out 02_QC/Pruned_list"))
```

# üìò Note on relatedness coefficients and cutoff values
#
# PLINK 1.9 and PLINK 2 use different measures of genetic relatedness:
#
#   ‚Ä¢ PLINK 1.9 uses the "pi-hat" value (IBD proportion),
#     representing the *proportion of alleles shared identical-by-descent*.
#
#   ‚Ä¢ PLINK 2 (via the KING method) uses the *kinship coefficient (œÜ)*,
#     which is equal to **half of the pi-hat value**:
#
#         œÜ = pi-hat / 2
#
# ---------------------------------------------------------------
# üîπ Comparison of theoretical values by relationship degree:
#
# | Relationship Type              | pi-hat (PLINK 1.9) | Kinship œÜ (PLINK 2) |
# |--------------------------------|--------------------|----------------------|
# | Monozygotic twins / duplicates | 1.000              | 0.500                |
# | 1st degree (parent‚Äìchild, full siblings) | 0.500 | 0.250 |
# | 2nd degree (grandparent‚Äìgrandchild, half-sibs, uncle‚Äìniece) | 0.250 | 0.125 |
# | 3rd degree (first cousins)     | 0.125              | 0.0625               |
# | Unrelated                      | < 0.0625           | < 0.03125            |
#
# ---------------------------------------------------------------
# üîπ Recommended cutoff values
#
# Because PLINK 2‚Äôs kinship coefficients are half the scale of PLINK 1.9‚Äôs pi-hat,
# the corresponding thresholds should also be halved.
#
# | Intended filter (remove all ‚â•) | PLINK 1.9 (--rel-cutoff) | PLINK 2 (--king-cutoff) |
# |--------------------------------|---------------------------|--------------------------|
# | 1st-degree relatives           | 0.25                      | 0.125                    |
# | 2nd-degree relatives           | 0.125                     | 0.0625                   |
# | 3rd-degree relatives           | 0.0625                    | 0.03125                  |
#
# ---------------------------------------------------------------
# üîπ Common practice
#
# In most QC pipelines:
#   - `--rel-cutoff 0.125` (PLINK 1.9)  ‚âà  `--king-cutoff 0.0625` (PLINK 2)
#     ‚Üí keeps only individuals less related than second-degree relatives.
#
#   - Some workflows use `--king-cutoff 0.0884` to include a small buffer,
#     accounting for statistical noise in kinship estimation.
#
# ---------------------------------------------------------------
# ‚úÖ Summary
#   - PLINK 1.9 ‚Üí uses pi-hat (IBD proportion)
#   - PLINK 2 ‚Üí uses KING kinship coefficient (‚âà pi-hat / 2)
#   - Therefore, halve your cutoff when switching from PLINK 1.9 to PLINK 2.

```{r #3.f - Quality Control (QC) Cryptic relatedness check --rel-cutoff}
# qc_rel_cutoff_plink2
# Step 2: Identify and exclude related individuals using KING-based cutoff (PLINK 2).
# We restrict to the pruned SNPs to avoid LD inflation.
# Threshold 0.2 ~ between 1st and 2nd degree; adjust to your protocol.
system(paste(
  plink_command,
  "--bfile 02_QC/QC7_het",
  "--extract 02_QC/Pruned_list.prune.in",
  "--king-cutoff 0.0884",
  "--out 02_QC/subject_rel"
))

# PLINK 2 writes:
#   02_QC/subject_rel.king.cutoff.in.id   -> samples to KEEP
#   02_QC/subject_rel.king.cutoff.out.id  -> samples to REMOVE
```

```{r}
#3.f - QC show related pairs above cutoff}
# qc_show_related_pairs_plink2 (with proper column headers)
# Step 2b: Display pairs of related individuals with kinship above the cutoff.

cutoff <- 0.0884  # keep aligned with the --king-cutoff used above

# Expected KING output from PLINK 2:
kin_plain <- "02_QC/subject_rel_pairs.kin0"
kin_gz    <- "02_QC/subject_rel_pairs.kin0.gz"
kin_file  <- if (file.exists(kin_plain)) kin_plain else if (file.exists(kin_gz)) kin_gz else NA

if (!is.na(kin_file)) {
  message("‚úÖ Reading KING table: ", kin_file)

  # Read file (with or without header)
  con <- if (endsWith(kin_file, ".gz")) gzfile(kin_file, open = "rt") else file(kin_file, open = "r")
  on.exit(close(con), add = TRUE)
  king_pairs <- read.table(con, header = FALSE, sep = "", stringsAsFactors = FALSE)

  # Assign proper PLINK 2 KING column names
  names(king_pairs) <- c("FID1", "IID1", "FID2", "IID2", "NSNP", "HetHet", "IBS0", "Kinship")

  # Filter pairs above cutoff
  related_pairs <- subset(king_pairs, Kinship > cutoff)

  message("Pairs above cutoff (kinship > ", cutoff, "): ", nrow(related_pairs))
  print(utils::head(related_pairs, 20))

  # Save filtered pairs
  out_tsv <- "02_QC/subject_rel_pairs.above_cutoff.tsv"
  write.table(related_pairs, out_tsv, sep = "\t", row.names = FALSE, quote = FALSE)
  message("Saved filtered pairs to: ", out_tsv)
} else {
  message("‚ö†Ô∏è KING table not found: expected 02_QC/subject_rel_pairs.kin0 (or .kin0.gz).")
}
```



```{r #3.f - Quality Control (QC) Cryptic relatedness check}
# qc_make_unrelated_dataset_plink2
# Step 3 (Option A): Keep only unrelated samples (recommended).
system(paste(
  plink_command,
  "--bfile 02_QC/QC7_het",
  "--keep 02_QC/subject_rel.king.cutoff.in.id",
  "--make-bed",
  "--out 02_QC/QC8_rel"
))

# (Option B): Alternatively, remove the related samples.
# system(paste(
#   plink_command,
#   "--bfile 02_QC/QC7_het",
#   "--remove 02_QC/subject_rel.king.cutoff.out.id",
#   "--make-bed",
#   "--out 02_QC/QC8_rel"
# ))
```

3.g - Quality Control (QC): Hardy-Weinberg Equilibrium (HWE) Filtering ‚öñÔ∏è
The Hardy-Weinberg Equilibrium (HWE) principle states that allele and genotype frequencies in a large, randomly mating population remain constant from generation to generation, provided no other evolutionary forces (like mutation, selection, or migration) are at play.
Rationale for Filtering
In a GWAS context, deviations from HWE (a very small p-value) are often not due to natural evolutionary forces, but rather indicate technical problems:
- Genotyping Error: The most common cause; the assay may be consistently failing to call specific genotypes accurately.
-Population Substructure: If the study population is a mix of highly divergent groups, HWE can be violated.We use a stringent p-value threshold (typically 1e-5) to remove problematic SNPs.

```{r #3.g - Quality Control (QC) Hardy-Weinberg equilibrium filtering}
# SECTION 7: Hardy-Weinberg equilibrium filtering

# Filter SNPs failing the Hardy-Weinberg equilibrium test (p-value < 1e-5).
system(paste(plink_command, " --bfile 02_QC/QC8_rel --hwe 1e-5 --pheno 01_Database/pheno.txt --write-snplist --make-bed --out 02_QC/QC9_hwe"))
```

3.h - Save Environment: Backup and Reproducibility üíæ
This final chunk of the Quality Control module is purely for workflow management and safety.

Rationale for Saving the Environment
In a lengthy analysis session that involves multiple steps, it's crucial to periodically save the R environment. The environment contains all the variables you have defined, including:

The detected directory paths (main, QC_dir, etc.).

Any intermediate data tables you loaded (e.g., the results_checksex table from the sex check).

Any objects created during diagnostic checks.

Saving the environment allows you to:

Resume Work: If your R session terminates unexpectedly, you can load the saved file (.RData) and continue exactly where you left off.

Ensure Reproducibility: It provides a snapshot of the exact environment used to produce the QC-filtered dataset (QC9_hwe).


```{r #3.h - Quality Control (QC) Save environment}
# SECTION 8: Save environment

# Save the R environment for backup and reproducibility.
save.image(paste(main, "Env_chunk_QC.RData", sep = ""))

# Confirm completion of the chunk.
print("End of chunk QC")
# End of chunk 3

```
